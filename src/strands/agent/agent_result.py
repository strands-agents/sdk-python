"""Agent result handling for SDK.

This module defines the AgentResult class which encapsulates the complete response from an agent's processing cycle.
"""

from dataclasses import dataclass
from typing import Any, Generic, Sequence, TypeVar, cast

from pydantic import BaseModel

from ..interrupt import Interrupt
from ..telemetry.metrics import EventLoopMetrics
from ..types.content import Message
from ..types.streaming import StopReason

T = TypeVar("T", bound=BaseModel)


@dataclass
class AgentResult(Generic[T]):
    """Represents the last result of invoking an agent with a prompt.

    This class is generic over the structured output model type. When an Agent is initialized
    with a structured_output_model, the returned AgentResult will be typed accordingly,
    enabling better type inference and IDE support.

    Type Parameters:
        T: The Pydantic BaseModel type for structured output. Defaults to BaseModel when
           no structured_output_model is specified.

    Examples:
        Basic usage without structured output:
            >>> agent = Agent(model=model)
            >>> result = agent("Hello")  # AgentResult[BaseModel]
            >>> print(result)

        With structured output and type inference:
            >>> class UserProfile(BaseModel):
            ...     name: str
            ...     age: int
            >>> agent: Agent[UserProfile] = Agent(
            ...     model=model,
            ...     structured_output_model=UserProfile
            ... )
            >>> result = agent("Extract user info")  # AgentResult[UserProfile]
            >>> if result.structured_output is not None:
            ...     name: str = result.structured_output.name  # Type-safe access
            ...     age: int = result.structured_output.age

    Attributes:
        stop_reason: The reason why the agent's processing stopped.
        message: The last message generated by the agent.
        metrics: Performance metrics collected during processing.
        state: Additional state information from the event loop.
        interrupts: List of interrupts if raised by user.
        structured_output: Parsed structured output when structured_output_model was specified.
            Type is T | None, where T is the model type specified in the Agent constructor.
    """

    stop_reason: StopReason
    message: Message
    metrics: EventLoopMetrics
    state: Any
    interrupts: Sequence[Interrupt] | None = None
    structured_output: T | None = None

    def __str__(self) -> str:
        """Get the agent's last message as a string.

        This method extracts and concatenates all text content from the final message, ignoring any non-text content
        like images or structured data.

        Returns:
            The agent's last message as a string.
        """
        content_array = self.message.get("content", [])

        result = ""
        for item in content_array:
            if isinstance(item, dict) and "text" in item:
                result += item.get("text", "") + "\n"
        return result

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "AgentResult":
        """Rehydrate an AgentResult from persisted JSON.

        Args:
            data: Dictionary containing the serialized AgentResult data
        Returns:
            AgentResult instance
        Raises:
            TypeError: If the data format is invalid@
        """
        if data.get("type") != "agent_result":
            raise TypeError(f"AgentResult.from_dict: unexpected type {data.get('type')!r}")

        message = cast(Message, data.get("message"))
        stop_reason = cast(StopReason, data.get("stop_reason"))

        return cls(message=message, stop_reason=stop_reason, metrics=EventLoopMetrics(), state={})

    def to_dict(self) -> dict[str, Any]:
        """Convert this AgentResult to JSON-serializable dictionary.

        Returns:
            Dictionary containing serialized AgentResult data
        """
        return {
            "type": "agent_result",
            "message": self.message,
            "stop_reason": self.stop_reason,
        }
